#!/usr/bin/env python3
"""
Generated HarnessComponent
Auto-generated by V5.0 Two-Phase Generation Pipeline
"""

import asyncio
import logging
import time
import json
from typing import Dict, Any, Optional, List

# Import HarnessComponent base class
from evidence.phase6_harness.day1_harness_component.harness_component import HarnessComponent
from evidence.phase2_component_library.day1_core_component_classes.enhanced_base import ComponentConfiguration
from fastapi import FastAPI, HTTPException
import uvicorn


class Api_Gateway(HarnessComponent):
    """
    Generated api_gateway component
    
    Auto-generated by V5.0 Two-Phase Generation Pipeline
    Extends HarnessComponent for stream-based communication
    """


    def __init__(self, config: Dict[str, Any]):
        """Initialize api_gateway component"""
        component_config = ComponentConfiguration(
            name="api_gateway",
            service_type="api_gateway",
            **config
        )
        
        super().__init__(component_config)
        
        # Component-specific initialization
        self.config = config
        self.processing_stats = {
            "messages_processed": 0,
            "processing_time_total": 0.0,
            "errors_count": 0
        }
        
        self.logger.info(f"üîß {self.name} (api_gateway) initialized")


    async def _initialize_component_resources(self):
        """Initialize component-specific resources"""
        self.logger.info(f"üîß Initializing {self.name} resources")
        
        try:
            
        # Initialize stream error tracking
        self.stream_errors = {}
        
        # Initialize resource handles
        self.resource_handles = {}
        
        # Validate expected streams will be available
        self.expected_input_streams = ['requests', 'incoming']
        self.expected_output_streams = ['responses', 'outgoing']
        
        # Initialize component state
        self.component_state = {
            "initialized": True,
            "initialization_time": time.time(),
            "status": "ready"
        }
            
            
        # Initialize FastAPI application
        self.app = FastAPI(title=f"{self.name} API")
        
        # Setup CORS if enabled
        if self.config.get('cors_enabled', False):
            from fastapi.middleware.cors import CORSMiddleware
            self.app.add_middleware(
                CORSMiddleware,
                allow_origins=["*"],
                allow_credentials=True,
                allow_methods=["*"],
                allow_headers=["*"],
            )
        
        # Setup API routes
        await self._setup_api_routes()
        
        # Store server configuration
        self.server_config = {
            "host": self.config.get('host', '0.0.0.0'),
            "port": self.config.get('port', 8080),
            "log_level": "info"
        }
            
            
        # Setup HTTP server
        self.server_port = self.config.get('port', 8080)
        self.server_host = self.config.get('host', '0.0.0.0')
        
        # Initialize request metrics
        self.request_metrics = {
            'total_requests': 0,
            'successful_requests': 0,
            'error_requests': 0
        }
            
            self.logger.info(f"‚úÖ {self.name} resources initialized successfully")
            
        except Exception as e:
            self.logger.error(f"‚ùå {self.name} resource initialization failed: {e}")
            raise


    async def process(self):
        """Main processing loop with stream handling"""
        try:
            
            # Poll multiple input streams
            streams_checked = 0
            
                # Check requests stream
                if 'requests' in self.receive_streams:
                    try:
                        message = await self.receive_message('requests', timeout=0.1)
                        if message is not None:
                            result = await self.process_message(message)
                            if result:
                                await self.send_result(result)
                    except Exception as e:
                        await self.handle_stream_error('requests', e)

                # Check incoming stream
                if 'incoming' in self.receive_streams:
                    try:
                        message = await self.receive_message('incoming', timeout=0.1)
                        if message is not None:
                            result = await self.process_message(message)
                            if result:
                                await self.send_result(result)
                    except Exception as e:
                        await self.handle_stream_error('incoming', e)
            
            # Brief pause if no messages processed
            if streams_checked == 0:
                await asyncio.sleep(0.01)
            
        except Exception as e:
            self.logger.error(f"‚ùå Processing error in {self.name}: {e}")
            await self.handle_processing_error(e)
    
    async def process_message(self, message_data: Any) -> Optional[Dict[str, Any]]:
        """Process individual message"""
        start_time = time.time()
        
        try:
            # Business logic processing
            result = await self.handle_task_request(message_data)
            
            # Update statistics
            processing_time = time.time() - start_time
            self.processing_stats["messages_processed"] += 1
            self.processing_stats["processing_time_total"] += processing_time
            
            return result
            
        except Exception as e:
            self.processing_stats["errors_count"] += 1
            self.logger.error(f"‚ùå Message processing error: {e}")
            raise
    
    async def send_result(self, result: Dict[str, Any]):
        """Send processing result to appropriate output streams"""
        
        # Send to responses stream
        if 'responses' in self.send_streams:
            try:
                await self.send_message('responses', result)
                self.logger.debug(f"‚úÖ Sent result to responses")
            except Exception as e:
                self.logger.error(f"‚ùå Failed to send to responses: {e}")

        # Send to outgoing stream
        if 'outgoing' in self.send_streams:
            try:
                await self.send_message('outgoing', result)
                self.logger.debug(f"‚úÖ Sent result to outgoing")
            except Exception as e:
                self.logger.error(f"‚ùå Failed to send to outgoing: {e}")
    
    async def handle_processing_error(self, error: Exception):
        """Handle processing errors with recovery"""
        self.logger.warning(f"‚ö†Ô∏è Handling processing error: {error}")
        
        # Error recovery logic
        await asyncio.sleep(0.1)  # Brief pause before retry


    async def _cleanup_component_resources(self):
        """Clean up component-specific resources"""
        self.logger.info(f"üßπ Cleaning up {self.name} resources")
        
        try:
            
            # Cleanup API server
            if hasattr(self, 'server') and self.server:
                try:
                    self.server.shutdown()
                except:
                    pass
            
            
        # Log final metrics
        self.logger.info(f"Final metrics: {self.request_metrics}")
            
            # Close any remaining resources
            if hasattr(self, 'resource_handles'):
                for handle_name, handle in self.resource_handles.items():
                    try:
                        if hasattr(handle, 'close'):
                            await handle.close()
                        elif hasattr(handle, 'disconnect'):
                            await handle.disconnect()
                        self.logger.debug(f"‚úÖ Closed {handle_name}")
                    except Exception as e:
                        self.logger.warning(f"‚ö†Ô∏è Error closing {handle_name}: {e}")
            
            self.logger.info(f"‚úÖ {self.name} cleanup completed")
            
        except Exception as e:
            self.logger.error(f"‚ùå {self.name} cleanup failed: {e}")
            # Don't re-raise cleanup errors


    async def handle_task_request(self, data: Any) -> Dict[str, Any]:
        """
        Handle incoming task management requests
        Generated from ComponentLogic definition
        """
        try:
            # Business logic implementation
            
            # Parse HTTP request
            method = data.get('method', 'GET')
            path = data.get('path', '/')
            body = data.get('body', {})
            
            if method == 'POST' and path == '/tasks':
                # Create task request
                task_data = {
                    'title': body.get('title', 'Untitled Task'),
                    'description': body.get('description', ''),
                    'priority': body.get('priority', 'medium'),
                    'created_at': time.time()
                }
                result = {
                    'status': 'request_received',
                    'type': 'create_task',
                    'data': task_data
                }
            elif method == 'GET' and path == '/tasks':
                # List tasks request
                result = {
                    'status': 'request_received', 
                    'type': 'list_tasks',
                    'data': data.get('query', {})
                }
            else:
                result = {
                    'status': 'error',
                    'message': f'Unsupported {method} {path}'
                }
            
            return result
            
        except Exception as e:
            self.logger.error(f"‚ùå Business method handle_task_request error: {e}")
            raise


    async def handle_stream_error(self, stream_name: str, error: Exception):
        """Handle stream operation errors"""
        self.logger.warning(f"‚ö†Ô∏è Stream error on {stream_name}: {error}")
        
        # Record error for monitoring
        if not hasattr(self, 'stream_errors'):
            self.stream_errors = {}
        
        if stream_name not in self.stream_errors:
            self.stream_errors[stream_name] = 0
        
        self.stream_errors[stream_name] += 1
        
        # Exponential backoff for repeated errors
        if self.stream_errors[stream_name] > 3:
            await asyncio.sleep(min(2.0 ** (self.stream_errors[stream_name] - 3), 30.0))

    def get_stream_status(self) -> Dict[str, Any]:
        """Get status of all component streams"""
        status = {
            "input_streams": {},
            "output_streams": {},
            "stream_errors": getattr(self, 'stream_errors', {})
        }
        
        # Check input streams
        for stream_name in ['requests', 'incoming']:
            if stream_name in self.receive_streams:
                connection = self.receive_streams[stream_name]
                status["input_streams"][stream_name] = {
                    "connected": True,
                    "message_count": connection.message_count,
                    "last_activity": connection.last_activity
                }
            else:
                status["input_streams"][stream_name] = {"connected": False}
        
        # Check output streams  
        for stream_name in ['responses', 'outgoing']:
            if stream_name in self.send_streams:
                connection = self.send_streams[stream_name]
                status["output_streams"][stream_name] = {
                    "connected": True,
                    "message_count": connection.message_count,
                    "last_activity": connection.last_activity
                }
            else:
                status["output_streams"][stream_name] = {"connected": False}
                
        return status

    async def send_to_multiple_streams(self, data: Dict[str, Any], stream_names: List[str] = None):
        """Send data to multiple output streams"""
        target_streams = stream_names or ['responses', 'outgoing']
        
        results = {}
        for stream_name in target_streams:
            try:
                success = await self.send_message(stream_name, data)
                results[stream_name] = success
            except Exception as e:
                results[stream_name] = False
                self.logger.error(f"‚ùå Failed to send to {stream_name}: {e}")
        
        return results

    async def check_stream_connectivity(self) -> Dict[str, bool]:
        """Check connectivity of all streams"""
        connectivity = {}
        
        # Check input streams
        for stream_name, connection in self.receive_streams.items():
            try:
                # Simple connectivity check - stream should not be closed
                connectivity[f"input_{stream_name}"] = not connection.stream._closed
            except:
                connectivity[f"input_{stream_name}"] = False
        
        # Check output streams
        for stream_name, connection in self.send_streams.items():
            try:
                connectivity[f"output_{stream_name}"] = not connection.stream._closed
            except:
                connectivity[f"output_{stream_name}"] = False
        
        return connectivity

    def get_stream_metrics(self) -> Dict[str, Any]:
        """Collect stream performance metrics"""
        metrics = {
            "total_input_streams": len(self.receive_streams),
            "total_output_streams": len(self.send_streams),
            "total_messages_received": 0,
            "total_messages_sent": 0,
            "stream_errors": sum(getattr(self, 'stream_errors', {}).values()),
            "stream_details": {}
        }
        
        # Input stream metrics
        for stream_name, connection in self.receive_streams.items():
            metrics["total_messages_received"] += connection.message_count
            metrics["stream_details"][f"input_{stream_name}"] = {
                "messages": connection.message_count,
                "last_activity": connection.last_activity,
                "buffer_size": connection.buffer_size
            }
        
        # Output stream metrics
        for stream_name, connection in self.send_streams.items():
            metrics["total_messages_sent"] += connection.message_count
            metrics["stream_details"][f"output_{stream_name}"] = {
                "messages": connection.message_count,
                "last_activity": connection.last_activity,
                "buffer_size": connection.buffer_size
            }
        
        return metrics